#!/usr/bin/env perl
use strict;
use warnings;
use IO::File;
use Data::Dumper;
use Time::HiRes qw(gettimeofday tv_interval);
use Getopt::Long;
use Carp;
use Storable;

my $opts = {};
my $k = 16;
GetOptions($opts, qw(k=s index=s@ query=s@));
if($opts->{k}) {
    $k=$opts->{k};
}

my $t0        = [gettimeofday];
my $bytes     = 0;
my $hashtable = {_sequences => {}}; # kmer-based hash lookup table
my $sequences = $hashtable->{_sequences};

if($opts->{query} && $opts->{index} && scalar @{$opts->{index}} > 1) {
    print qq[Can only use one --index with --query\n];
    exit 1;
}

if($opts->{query} && !$opts->{index}) {
    print qq[Must use one --index with --query\n];
    exit 1;
}

if($opts->{query}) {
    # load index from disk
    $hashtable = retrieve $opts->{index}->[0];
    $sequences = $hashtable->{_sequences}; # reset ref

    readfa(\&align, @{$opts->{query}});
    print "Aligned in @{[tv_interval $t0]} secs\n";
    exit 0;
}

if($opts->{index}) {
    readfa(\&hash, @{$opts->{index}});
    store $hashtable, 'index.stbl';
    print "Built hashtable in @{[tv_interval $t0]} secs\n";
    exit 0;
}

sub readfa {
    my ($cb, @files) = @_;

    for my $fn (@files) {
	my $io = IO::File->new($fn);
	my ($id, $seq);

	while(my $line = <$io>) {
	    $bytes += length $line;
	    chomp $line;
	    if($line =~ m{^>}smix) {
		#########
		# extend hashtable with the last-read sequence
		#
		if($id) { 
		    $sequences->{$id} = $seq; # note conflict across files/sequences
		    $cb->($id, $seq);
		}

		($id) = $line =~ m{^>\s*(\S+)}smix;
		$seq = "";
		next;
	    }
	    $seq .= $line;
	}

	#########
	# extend hashtable with the final sequence
	#
	$sequences->{$id} = $seq; # note conflict across files/sequences
	$cb->($id, $seq);
	$io->close;
    }
}

sub hash {
    my ($id, $seq) = @_;

    for my $start (0..(length $seq)-$k) {
	my $subseq = substr $seq, $start, $k;
	if(!exists $hashtable->{$subseq}) {
	    $hashtable->{$subseq} = [];
	}
	push @{$hashtable->{$subseq}}, { id => $id, start => $start };
    }
}

sub align {
    my ($id, $seq) = @_;

    my $hits = {};

    for my $start (0..(length $seq)-$k) {
	my $subseq = substr $seq, $start, $k;

	for my $hit (@{$hashtable->{$subseq}||[]}) {
	    my $hit_id    = $hit->{id};
	    my $hit_start = $hit->{start};
	    my $last_hit  = scalar @{$hits->{$hit_id}||[]} ? $hits->{$hit_id}->[-1] : undef;

	    if($last_hit && $start-1 == $last_hit->{query_end}-$k+1) {
		#########
		# extend hit for query
		#
		$last_hit->{query_end} ++;
		next;
	    }

	    push @{$hits->{$hit_id}}, {
		query_start => $start,
		query_end   => $start+$k-1,
		hit_start   => $hit_start,
	    };
	}
    }

    for my $hit_id (keys %{$hits}) {
	printf ">%-16s                %s\n", $hit_id, $sequences->{$hit_id};
	for my $hit (@{$hits->{$hit_id}}) {
	    my $query_start = $hit->{query_start};
	    my $query_end   = $hit->{query_end};
	    my $hit_start   = $hit->{hit_start};

	    printf "+%-16s [%5d..%-5d] %s%s\n",
		$id,
		$query_start, $query_end,
		" "x$hit_start,
		substr $sequences->{$id}, $query_start, $query_end-$query_start+1;
	}
    }
    print "\n";
}
